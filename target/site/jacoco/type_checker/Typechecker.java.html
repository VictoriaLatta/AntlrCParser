<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Typechecker.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CminusCompiler</a> &gt; <a href="index.source.html" class="el_package">type_checker</a> &gt; <span class="el_source">Typechecker.java</span></div><h1>Typechecker.java</h1><pre class="source lang-java linenums">package type_checker;

import type_checker_syntax.StructureDeclaration;
import type_checker_syntax.Variable;
import type_checker_syntax.AssignmentStmt;
import type_checker_syntax.VariableExp;
import type_checker_syntax.VariableLhs;
import type_checker_syntax.Type;
import type_checker_syntax.StructureName;
import type_checker_syntax.IntType;
import type_checker_syntax.IntExp;
import type_checker_syntax.BinopExp;
import type_checker_syntax.Lhs;
import type_checker_syntax.Stmt;
import type_checker_syntax.ReturnVoidStmt;
import type_checker_syntax.FieldAccessExp;
import type_checker_syntax.DereferenceExp;
import type_checker_syntax.VariableDeclaration;
import type_checker_syntax.ExpStmt;
import type_checker_syntax.FunctionCallExp;
import type_checker_syntax.EqualsOp;
import type_checker_syntax.IfStmt;
import type_checker_syntax.Op;
import type_checker_syntax.FreeStmt;
import type_checker_syntax.PointerType;
import type_checker_syntax.VoidType;
import type_checker_syntax.SizeofExp;
import type_checker_syntax.Program;
import type_checker_syntax.WhileStmt;
import type_checker_syntax.BreakStmt;
import type_checker_syntax.PlusOp;
import type_checker_syntax.FieldAccessLhs;
import type_checker_syntax.CastExp;
import type_checker_syntax.FunctionDefinition;
import type_checker_syntax.FunctionName;
import type_checker_syntax.DereferenceLhs;
import type_checker_syntax.StructureType;
import type_checker_syntax.BoolType;
import type_checker_syntax.ReturnExpStmt;
import type_checker_syntax.FieldName;
import type_checker_syntax.VariableDeclarationInitializationStmt;
import type_checker_syntax.AddressOfExp;
import type_checker_syntax.ContinueStmt;
import type_checker_syntax.SequenceStmt;
import type_checker_syntax.BoolExp;
import type_checker_syntax.Exp;

import java.util.Map;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Set;
import java.util.HashSet;

<span class="pc bpc" id="L54" title="1 of 2 branches missed.">public class Typechecker {</span>
    // maps the name of the structure to its fields, and each of those
    // fields to its type
    private final Map&lt;StructureName, LinkedHashMap&lt;FieldName, Type&gt;&gt; structDecs;

    // maps each function name to its parameter types and return type
    private final Map&lt;FunctionName, Pair&lt;Type[], Type&gt;&gt; functionDefs;

<span class="fc" id="L62">    private Typechecker(final Program program) throws TypeErrorException {</span>
        // have to load these before checking structure or function validity
<span class="fc" id="L64">        structDecs = makeStructMapping(program.structDecs);</span>
<span class="fc" id="L65">        ensureStructureFieldsValid();</span>

<span class="fc" id="L67">        functionDefs = makeFunctionMapping(program.functionDefs);</span>

<span class="fc bfc" id="L69" title="All 2 branches covered.">        for (final FunctionDefinition def : program.functionDefs) {</span>
<span class="fc" id="L70">            typecheckFunctionDef(def);</span>
        }
<span class="fc" id="L72">    }</span>

    // makes sure that structure fields don't refer to non-existent structures
    private void ensureStructureFieldsValid() throws TypeErrorException {
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">        for (final LinkedHashMap&lt;FieldName, Type&gt; fields : structDecs.values()) {</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">            for (final Type type : fields.values()) {</span>
<span class="nc" id="L78">                ensureValidType(type);</span>
<span class="nc" id="L79">            }</span>
<span class="nc" id="L80">        }</span>
<span class="fc" id="L81">    }</span>
    
    // intended for testing
    public static Type expTypeForTesting(final Exp exp) throws TypeErrorException {
<span class="fc" id="L85">        final Typechecker checker =</span>
            new Typechecker(new Program(new StructureDeclaration[0],
                                        new FunctionDefinition[0]));
<span class="fc" id="L88">        return checker.expTypeNoScopeForTesting(exp);</span>
    }
    
    public static void typecheckProgram(final Program program) throws TypeErrorException {
<span class="fc" id="L92">        new Typechecker(program);</span>
<span class="fc" id="L93">    }</span>
    
    // not permitted to have multiple functions with the same name
    private Map&lt;FunctionName, Pair&lt;Type[], Type&gt;&gt;
        makeFunctionMapping(final FunctionDefinition[] functions) throws TypeErrorException {

<span class="fc" id="L99">        final Map&lt;FunctionName, Pair&lt;Type[], Type&gt;&gt; result =</span>
            new HashMap&lt;FunctionName, Pair&lt;Type[], Type&gt;&gt;();

<span class="fc bfc" id="L102" title="All 2 branches covered.">        for (final FunctionDefinition def : functions) {</span>
<span class="fc" id="L103">            final Type[] parameters = parameterTypes(def.parameters);</span>
<span class="fc" id="L104">            final Pair&lt;Type[], Type&gt; value =</span>
                new Pair&lt;Type[], Type&gt;(parameters, def.returnType);
<span class="fc" id="L106">            result.put(def.name, value);</span>
        }

<span class="fc bfc" id="L109" title="All 2 branches covered.">        if (result.size() != functions.length) {</span>
<span class="fc" id="L110">            throw new TypeErrorException(&quot;Duplicate function name&quot;);</span>
        }

<span class="fc" id="L113">        return result;</span>
    }

    // throws exception if any are void
    private Type[] parameterTypes(final VariableDeclaration[] vars) throws TypeErrorException {
<span class="fc" id="L118">        final Type[] result = new Type[vars.length];</span>

<span class="fc bfc" id="L120" title="All 2 branches covered.">        for (int index = 0; index &lt; vars.length; index++) {</span>
<span class="fc" id="L121">            final Type current = vars[index].type;</span>
<span class="fc" id="L122">            ensureValidType(current);</span>
<span class="fc" id="L123">            ensureNonVoidType(current);</span>
<span class="fc" id="L124">            result[index] = current;</span>
        }

<span class="fc" id="L127">        return result;</span>
    }

    // the user _can_ write an invalid type, e.g., reference a non-existent structure
    private void ensureValidType(final Type type) throws TypeErrorException {
<span class="fc bfc" id="L132" title="All 2 branches covered.">        if (type instanceof StructureType) {</span>
<span class="fc" id="L133">            final StructureName name = ((StructureType)type).name;</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">            if (!structDecs.containsKey(name)) {</span>
<span class="fc" id="L135">                throw new TypeErrorException(&quot;Non-existent structure referenced: &quot; +</span>
<span class="fc" id="L136">                                             name.toString());</span>
            }
        }
<span class="fc" id="L139">    }</span>
            
    private static void ensureNonVoidType(final Type type) throws TypeErrorException {
<span class="fc bfc" id="L142" title="All 2 branches covered.">        if (type instanceof VoidType) {</span>
<span class="fc" id="L143">            throw new TypeErrorException(&quot;Void type illegal here&quot;);</span>
        }
<span class="fc" id="L145">    }</span>
    
    // not permitted to have multiple structure declarations with the same name
    private static Map&lt;StructureName, LinkedHashMap&lt;FieldName, Type&gt;&gt;
        makeStructMapping(final StructureDeclaration[] structDecs) throws TypeErrorException {

<span class="fc" id="L151">        final Map&lt;StructureName, LinkedHashMap&lt;FieldName, Type&gt;&gt; result =</span>
            new HashMap&lt;StructureName, LinkedHashMap&lt;FieldName, Type&gt;&gt;();

<span class="pc bpc" id="L154" title="1 of 2 branches missed.">        for (final StructureDeclaration dec : structDecs) {</span>
<span class="nc" id="L155">            final LinkedHashMap&lt;FieldName, Type&gt; fieldMapping =</span>
<span class="nc" id="L156">                makeFieldMapping(dec.fields);</span>
<span class="nc" id="L157">            result.put(dec.name, fieldMapping);</span>
        }

<span class="pc bpc" id="L160" title="1 of 2 branches missed.">        if (result.size() != structDecs.length) {</span>
<span class="nc" id="L161">            throw new TypeErrorException(&quot;Duplicate structure name&quot;);</span>
        }

<span class="fc" id="L164">        return result;</span>
    }

    // not permitted to have repeated field names in the same structure
    // fields cannot have void types
    private static LinkedHashMap&lt;FieldName, Type&gt;
        makeFieldMapping(final VariableDeclaration[] fields) throws TypeErrorException {
        
<span class="nc" id="L172">        final LinkedHashMap&lt;FieldName, Type&gt; result =</span>
            new LinkedHashMap&lt;FieldName, Type&gt;();

<span class="nc bnc" id="L175" title="All 2 branches missed.">        for (final VariableDeclaration dec : fields) {</span>
<span class="nc" id="L176">            ensureNonVoidType(dec.type);</span>
<span class="nc" id="L177">            result.put(new FieldName(dec.variable.name), dec.type);</span>
        }

<span class="nc bnc" id="L180" title="All 2 branches missed.">        if (result.size() != fields.length) {</span>
<span class="nc" id="L181">            throw new TypeErrorException(&quot;Duplicate field name&quot;);</span>
        }

<span class="nc" id="L184">        return result;</span>
    }
    
    private void typecheckFunctionDef(final FunctionDefinition fdef) throws TypeErrorException {
<span class="fc" id="L188">        final InScope initialScope = new InScope(fdef.returnType,</span>
<span class="fc" id="L189">                                                 initialVariableMapping(fdef.parameters),</span>
                                                 false);
<span class="fc" id="L191">        final Pair&lt;InScope, Boolean&gt; stmtResult = initialScope.typecheckStmt(fdef.body);</span>

<span class="fc bfc" id="L193" title="All 4 branches covered.">        if (!stmtResult.second.booleanValue() &amp;&amp;</span>
            !(fdef.returnType instanceof VoidType)) {
<span class="fc" id="L195">            throw new TypeErrorException(&quot;Missing return in &quot; + fdef.name.toString());</span>
        }
<span class="fc" id="L197">    }</span>

    // error if duplicate variable names are used
    private static Map&lt;Variable, Type&gt; initialVariableMapping(final VariableDeclaration[] parameters) throws TypeErrorException {
<span class="fc" id="L201">        final Map&lt;Variable, Type&gt; result = new HashMap&lt;Variable, Type&gt;();</span>

<span class="fc bfc" id="L203" title="All 2 branches covered.">        for (final VariableDeclaration dec : parameters) {</span>
<span class="fc" id="L204">            result.put(dec.variable, dec.type);</span>
        }

<span class="pc bpc" id="L207" title="1 of 2 branches missed.">        if (result.size() != parameters.length) {</span>
<span class="nc" id="L208">            throw new TypeErrorException(&quot;Duplicate variable name in function parameters&quot;);</span>
        }

<span class="fc" id="L211">        return result;</span>
    }
    
    private void checkMakeStructure(final StructureName name,
                                    final Type[] parameterTypes) throws TypeErrorException {
<span class="nc" id="L216">        final LinkedHashMap&lt;FieldName, Type&gt; expected = structDecs.get(name);</span>

<span class="nc bnc" id="L218" title="All 2 branches missed.">        if (expected != null) {</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">            if (expected.size() == parameterTypes.length) {</span>
<span class="nc" id="L220">                int parameterIndex = 0;</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">                for (final Type expectedType : expected.values()) {</span>
<span class="nc" id="L222">                    final Type receivedType = parameterTypes[parameterIndex++];</span>
<span class="nc" id="L223">                    ensureTypesSame(expectedType, receivedType);</span>
<span class="nc" id="L224">                }</span>
<span class="nc" id="L225">            } else {</span>
<span class="nc" id="L226">                throw new TypeErrorException(&quot;Expected &quot; + expected.size() +</span>
                                             &quot; params; got &quot; + parameterTypes.length + &quot; params&quot;);
            }
        } else {
<span class="nc" id="L230">            throw new TypeErrorException(&quot;No such structure defined: &quot; + name.toString());</span>
        }
<span class="nc" id="L232">    }</span>

    // returns the return type
    private Type checkFunctionCall(final FunctionName name,
                                   final Type[] parameterTypes) throws TypeErrorException {
<span class="fc" id="L237">        final Pair&lt;Type[], Type&gt; expected = functionDefs.get(name);</span>

<span class="fc bfc" id="L239" title="All 2 branches covered.">        if (expected != null) {</span>
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">            if (parameterTypes.length == expected.first.length) {</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">                for (int index = 0; index &lt; parameterTypes.length; index++) {</span>
<span class="nc" id="L242">                    ensureTypesSame(expected.first[index], parameterTypes[index]);</span>
                }
<span class="nc" id="L244">                return expected.second;</span>
            } else {
<span class="fc" id="L246">                throw new TypeErrorException(&quot;Function &quot; + name.toString() +</span>
                                             &quot; has arity &quot; + expected.first.length +
                                             &quot;; was called with &quot; +
                                             parameterTypes.length + &quot; parameters&quot;);
            }
        } else {
<span class="fc" id="L252">            throw new TypeErrorException(&quot;No such function defined: &quot; + name.toString());</span>
        }
    } // checkFunctionCall
    
    private static void ensureTypesSame(final Type expected, final Type received) throws TypeErrorException {
<span class="fc bfc" id="L257" title="All 2 branches covered.">        if (!expected.equals(received)) {</span>
<span class="fc" id="L258">            throw new TypeErrorException(expected, received);</span>
        }
<span class="fc" id="L260">    }</span>

    private static Type binopType(final Type left, final Op op, final Type right) throws TypeErrorException {
<span class="fc" id="L263">        final IntType intType = new IntType();</span>
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">        if (op instanceof PlusOp) {</span>
            // TWO kinds are permitted:
            // int + int: returns int
            // pointer + int: returns same pointer type
            //
            // in both cases, the right side is an int
<span class="fc" id="L270">            ensureTypesSame(intType, right);</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">            if (left instanceof IntType) {</span>
                // int + int returns int
<span class="fc" id="L273">                return intType;</span>
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">            } else if (left instanceof PointerType) {</span>
<span class="fc" id="L275">                return left;</span>
            } else {
<span class="nc" id="L277">                throw new TypeErrorException(&quot;invalid lhs for +: &quot; + left.toString());</span>
            }
<span class="nc bnc" id="L279" title="All 2 branches missed.">        } else if (op instanceof EqualsOp) {</span>
            // type == type = boolean
            // both need to be of the same type
<span class="nc" id="L282">            ensureTypesSame(left, right);</span>
<span class="nc" id="L283">            return new BoolType();</span>
        } else {
            // should be no other operators
<span class="nc bnc" id="L286" title="All 2 branches missed.">            assert(false);</span>
<span class="nc" id="L287">            throw new TypeErrorException(&quot;Unknown operator: &quot; + op.toString());</span>
        }
    } // binopType

    // intended for testing
    private Type expTypeNoScopeForTesting(final Exp exp) throws TypeErrorException {
<span class="fc" id="L293">        return new InScope(new VoidType(),</span>
                           new HashMap&lt;Variable, Type&gt;(),
<span class="fc" id="L295">                           false).typeofExp(exp);</span>
    }
    
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">    private class InScope {</span>
        // return type of the function we are currently in
        private final Type returnType;
        // maps variables in scope to their corresponding type
        private final Map&lt;Variable, Type&gt; inScope;
        // records if we are in a while loop or not
        private final boolean inWhile;

        public InScope(final Type returnType,
                       final Map&lt;Variable, Type&gt; inScope,
<span class="fc" id="L308">                       final boolean inWhile) {</span>
<span class="fc" id="L309">            this.returnType = returnType;</span>
<span class="fc" id="L310">            this.inScope = inScope;</span>
<span class="fc" id="L311">            this.inWhile = inWhile;</span>
<span class="fc" id="L312">        }</span>

        private InScope addVariable(final Variable variable,
                                    final Type variableType) {
<span class="fc" id="L316">            final Map&lt;Variable, Type&gt; copy =</span>
                new HashMap&lt;Variable, Type&gt;(inScope);
<span class="fc" id="L318">            copy.put(variable, variableType);</span>
<span class="fc" id="L319">            return new InScope(returnType, copy, inWhile);</span>
        }

        private InScope setInWhile() {
<span class="fc" id="L323">            return new InScope(returnType, inScope, true);</span>
        }
        
        private Type typeofAccess(final Type maybeStructureType,
                                  final FieldName field) throws TypeErrorException {
<span class="nc bnc" id="L328" title="All 2 branches missed.">            if (maybeStructureType instanceof StructureType) {</span>
<span class="nc" id="L329">                final StructureName name = ((StructureType)maybeStructureType).name;</span>
<span class="nc" id="L330">                final LinkedHashMap&lt;FieldName, Type&gt; expected = structDecs.get(name);</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">                if (expected != null) {</span>
<span class="nc" id="L332">                    final Type fieldType = expected.get(field);</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">                    if (fieldType != null) {</span>
<span class="nc" id="L334">                        return fieldType;</span>
                    } else {
<span class="nc" id="L336">                        throw new TypeErrorException(&quot;Structure &quot; + name.toString() +</span>
<span class="nc" id="L337">                                                     &quot; does not have field &quot; + field.toString());</span>
                    }
                } else {
<span class="nc" id="L340">                    throw new TypeErrorException(&quot;No structure with name: &quot; + name.toString());</span>
                }
            } else {
<span class="nc" id="L343">                throw new TypeErrorException(&quot;Expected structure type; received: &quot; +</span>
<span class="nc" id="L344">                                             maybeStructureType.toString());</span>
            }
        }

        private Type typeofDereference(final Type maybePointerType) throws TypeErrorException {
<span class="fc bfc" id="L349" title="All 2 branches covered.">            if (maybePointerType instanceof PointerType) {</span>
                // dereferencing a pointer yields whatever its underlying type is
<span class="fc" id="L351">                return ((PointerType)maybePointerType).pointsTo;</span>
            } else {
<span class="fc" id="L353">                throw new TypeErrorException(&quot;Expected pointer type; received: &quot; +</span>
<span class="fc" id="L354">                                             maybePointerType.toString());</span>
            }
        }
        
        private Type typeofLhs(final Lhs lhs) throws TypeErrorException {
<span class="fc bfc" id="L359" title="All 2 branches covered.">            if (lhs instanceof VariableLhs) {</span>
<span class="fc" id="L360">                return lookupVariable(((VariableLhs)lhs).variable);</span>
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">            } else if (lhs instanceof FieldAccessLhs) {</span>
<span class="nc" id="L362">                final FieldAccessLhs asAccess = (FieldAccessLhs)lhs;</span>
<span class="nc" id="L363">                return typeofAccess(typeofLhs(asAccess.lhs),</span>
                                    asAccess.field);
<span class="pc bpc" id="L365" title="1 of 2 branches missed.">            } else if (lhs instanceof DereferenceLhs) {</span>
<span class="fc" id="L366">                final Type nestedType =</span>
<span class="fc" id="L367">                    typeofLhs(((DereferenceLhs)lhs).lhs);</span>
<span class="fc" id="L368">                return typeofDereference(nestedType);</span>
            } else {
<span class="nc bnc" id="L370" title="All 2 branches missed.">                assert(false);</span>
<span class="nc" id="L371">                throw new TypeErrorException(&quot;Unknown lhs: &quot; +lhs.toString());</span>
            }
        }
                    
        private Type[] typeofExps(final Exp[] exps) throws TypeErrorException {
<span class="fc" id="L376">            final Type[] types = new Type[exps.length];</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">            for (int index = 0; index &lt; exps.length; index++) {</span>
<span class="fc" id="L378">                types[index] = typeofExp(exps[index]);</span>
            }
<span class="fc" id="L380">            return types;</span>
        }

        // Look up the type of the variable.
        // If it's not present in the map, then it's not in scope.
        private Type lookupVariable(final Variable var) throws TypeErrorException {
<span class="fc" id="L386">            final Type varType = inScope.get(var);</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">            if (varType == null) {</span>
<span class="fc" id="L388">                throw new TypeErrorException(&quot;Variable not in scope: &quot; + var);</span>
            }
<span class="fc" id="L390">            return varType;</span>
        }
        
        public Type typeofExp(final Exp exp) throws TypeErrorException {
<span class="fc bfc" id="L394" title="All 2 branches covered.">            if (exp instanceof IntExp) {</span>
<span class="fc" id="L395">                return new IntType();</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">            } else if (exp instanceof BoolExp) {</span>
<span class="fc" id="L397">                return new BoolType();</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">            } else if (exp instanceof VariableExp) {</span>
<span class="fc" id="L399">                return lookupVariable(((VariableExp)exp).variable);</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">            }  else if (exp instanceof SizeofExp) {</span>
                // takes a type and returns an int
                // there is no sort of checking that can be done on the type
<span class="fc" id="L403">                return new IntType();</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">            } else if (exp instanceof BinopExp) {</span>
                // the return type and expected parameter types all depend
                // on the operator.  In all cases, we need to get the types
                // of the operands, and then check if this matches with the
                // operator
<span class="fc" id="L409">                final BinopExp asBinop = (BinopExp)exp;</span>
<span class="fc" id="L410">                final Type leftType = typeofExp(asBinop.left);</span>
<span class="fc" id="L411">                final Type rightType = typeofExp(asBinop.right);</span>
<span class="fc" id="L412">                return binopType(leftType, asBinop.op, rightType);</span>
<span class="fc bfc" id="L413" title="All 2 branches covered.">            } else if (exp instanceof FunctionCallExp) {</span>
<span class="fc" id="L414">                final FunctionCallExp asCall = (FunctionCallExp)exp;</span>
<span class="pc" id="L415">                return checkFunctionCall(asCall.name,</span>
<span class="fc" id="L416">                                         typeofExps(asCall.parameters));</span>
<span class="pc bpc" id="L417" title="1 of 2 branches missed.">            } else if (exp instanceof CastExp) {</span>
                // Explicit cast.  Trust the user.  Ideally, we'd check
                // this at runtime.  We still need to look at the expression
                // to make sure that this is itself well-typed.
<span class="nc" id="L421">                final CastExp asCast = (CastExp)exp;</span>
<span class="nc" id="L422">                typeofExp(asCast.exp);</span>
<span class="nc" id="L423">                return asCast.type;</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">            } else if (exp instanceof AddressOfExp) {</span>
<span class="fc" id="L425">                final Type nested = typeofLhs(((AddressOfExp)exp).lhs);</span>
                // point to this now
<span class="fc" id="L427">                return new PointerType(nested);</span>
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">            } else if (exp instanceof DereferenceExp) {</span>
<span class="fc" id="L429">                final Type nested = typeofExp(((DereferenceExp)exp).exp);</span>
<span class="fc" id="L430">                return typeofDereference(nested);</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">            } else if (exp instanceof FieldAccessExp) {</span>
<span class="nc" id="L432">                final FieldAccessExp asAccess = (FieldAccessExp)exp;</span>
<span class="nc" id="L433">                return typeofAccess(typeofExp(asAccess.exp),</span>
                                    asAccess.field);
            } else {
<span class="nc bnc" id="L436" title="All 2 branches missed.">                assert(false);</span>
<span class="nc" id="L437">                throw new TypeErrorException(&quot;Unrecognized expression: &quot; + exp.toString());</span>
            }
        } // typeofExp

        // returns any new scope to use, along with whether or not return was observed on
        // all paths
        public Pair&lt;InScope, Boolean&gt; typecheckStmt(final Stmt stmt) throws TypeErrorException {
<span class="fc bfc" id="L444" title="All 2 branches covered.">            if (stmt instanceof IfStmt) {</span>
<span class="fc" id="L445">                final IfStmt asIf = (IfStmt)stmt;</span>
<span class="fc" id="L446">                ensureTypesSame(new BoolType(), typeofExp(asIf.guard));</span>

                // since the true and false branches form their own blocks, we
                // don't care about any variables they put in scope
<span class="fc" id="L450">                final Pair&lt;InScope, Boolean&gt; leftResult = typecheckStmt(asIf.ifTrue);</span>
<span class="fc" id="L451">                final Pair&lt;InScope, Boolean&gt; rightResult = typecheckStmt(asIf.ifFalse);</span>
<span class="fc" id="L452">                final boolean returnOnBoth =</span>
<span class="fc bfc" id="L453" title="All 4 branches covered.">                    leftResult.second.booleanValue() &amp;&amp; rightResult.second.booleanValue();</span>
<span class="fc" id="L454">                return new Pair&lt;InScope, Boolean&gt;(this, returnOnBoth);</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">            } else if (stmt instanceof WhileStmt) {</span>
<span class="fc" id="L456">                final WhileStmt asWhile = (WhileStmt)stmt;</span>
<span class="fc" id="L457">                ensureTypesSame(new BoolType(), typeofExp(asWhile.guard));</span>

                // Don't care about variables in the while.
                // Because the body of the while loop will never execute if the condition is
                // initially false, even if all paths in the while loop have return, this doesn't
                // mean that we are guaranteed to hit return.
<span class="fc" id="L463">                setInWhile().typecheckStmt(asWhile.body);</span>
<span class="fc" id="L464">                return new Pair&lt;InScope, Boolean&gt;(this, Boolean.valueOf(false));</span>
<span class="fc bfc" id="L465" title="All 4 branches covered.">            } else if (stmt instanceof BreakStmt ||</span>
                       stmt instanceof ContinueStmt) {
<span class="fc bfc" id="L467" title="All 2 branches covered.">                if (!inWhile) {</span>
<span class="fc" id="L468">                    throw new TypeErrorException(&quot;Break or continue outside of loop&quot;);</span>
                }
<span class="fc" id="L470">                return new Pair&lt;InScope, Boolean&gt;(this, Boolean.valueOf(false));</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">            } else if (stmt instanceof VariableDeclarationInitializationStmt) {</span>
<span class="fc" id="L472">                final VariableDeclarationInitializationStmt dec =</span>
                    (VariableDeclarationInitializationStmt)stmt;
<span class="fc" id="L474">                final Type expectedType = dec.varDec.type;</span>
<span class="fc" id="L475">                ensureNonVoidType(expectedType);</span>
<span class="fc" id="L476">                ensureValidType(expectedType);</span>
<span class="fc" id="L477">                ensureTypesSame(expectedType,</span>
<span class="fc" id="L478">                                typeofExp(dec.exp));</span>
<span class="fc" id="L479">                final InScope resultInScope =</span>
<span class="fc" id="L480">                    addVariable(dec.varDec.variable, expectedType);</span>
<span class="fc" id="L481">                return new Pair&lt;InScope, Boolean&gt;(resultInScope, Boolean.valueOf(false));</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">            } else if (stmt instanceof AssignmentStmt) {</span>
<span class="fc" id="L483">                final AssignmentStmt asAssign = (AssignmentStmt)stmt;</span>
<span class="fc" id="L484">                ensureTypesSame(typeofLhs(asAssign.lhs),</span>
<span class="fc" id="L485">                                typeofExp(asAssign.exp));</span>
<span class="fc" id="L486">                return new Pair&lt;InScope, Boolean&gt;(this, Boolean.valueOf(false));</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">            } else if (stmt instanceof ReturnVoidStmt) {</span>
<span class="fc" id="L488">                ensureTypesSame(new VoidType(), returnType);</span>
<span class="fc" id="L489">                return new Pair&lt;InScope, Boolean&gt;(this, Boolean.valueOf(true));</span>
<span class="fc bfc" id="L490" title="All 2 branches covered.">            } else if (stmt instanceof ReturnExpStmt) {</span>
<span class="fc" id="L491">                final Type receivedType = typeofExp(((ReturnExpStmt)stmt).exp);</span>
<span class="fc" id="L492">                ensureTypesSame(returnType, receivedType);</span>
<span class="fc" id="L493">                return new Pair&lt;InScope, Boolean&gt;(this, Boolean.valueOf(true));</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">            } else if (stmt instanceof FreeStmt) {</span>
<span class="pc" id="L495">                ensureTypesSame(new PointerType(new VoidType()),</span>
<span class="fc" id="L496">                                typeofExp(((FreeStmt)stmt).value));</span>
<span class="nc" id="L497">                return new Pair&lt;InScope, Boolean&gt;(this, Boolean.valueOf(false));</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">            } else if (stmt instanceof SequenceStmt) {</span>
<span class="fc" id="L499">                final SequenceStmt asSeq = (SequenceStmt)stmt;</span>
<span class="fc" id="L500">                final Pair&lt;InScope, Boolean&gt; fromLeft = typecheckStmt(asSeq.first);</span>
                
<span class="fc bfc" id="L502" title="All 2 branches covered.">                if (fromLeft.second.booleanValue()) {</span>
<span class="fc" id="L503">                    throw new TypeErrorException(&quot;Dead code from early return&quot;);</span>
                }

<span class="fc" id="L506">                return fromLeft.first.typecheckStmt(asSeq.second);</span>
<span class="pc bpc" id="L507" title="1 of 2 branches missed.">            } else if (stmt instanceof ExpStmt) {</span>
                // Just need to check that it's well-typed.  Permitted to
                // return anything.
<span class="fc" id="L510">                typeofExp(((ExpStmt)stmt).exp);</span>
<span class="fc" id="L511">                return new Pair&lt;InScope, Boolean&gt;(this, Boolean.valueOf(false));</span>
            } else {
<span class="nc bnc" id="L513" title="All 2 branches missed.">                assert(false);</span>
<span class="nc" id="L514">                throw new TypeErrorException(&quot;Unrecognized statement: &quot; + stmt.toString());</span>
            }
        } // typecheckStmt
    } // InScope
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>